---
layout: blog
title: 프렌드와 연산자 중복
date: 2025-10-02 9:00:00 +0900
categories: [LECTURE, 객체지향프로그래밍II]
permalink: /blog/posts/25-10-02-TIL
---

### 객체지향프로그래밍II(김정준) 5주차 강의내용

**친구**<br>
내 가족의 일원은 아니지만 내 가족과 동일한 권한을 가진 일원으로 인정받은 사람

**C++ 프렌드**

- 프렌드 함수<br>
  - 클래스의 멤버 함수가 아닌 외부 함수<br>
    전역 함수<br>
    다른 클래스의 멤버 함수<br>
  - friend 키워드로 클래스 내에 선언된 함수<br>
    클래스의 모든 멤버를 접근할 수 있는 권한 부여<br>
    프렌드 함수라고 부름<br>
  - 프렌드 선언의 필요성<br>
    클래스의 멤버로 선언하기에는 무리가 있고, 클래스의 모든 멤버를 자유롭게 접근할 수 있는 일부 외부 함수 작성 시

<img src="/assets/images/2025/10/02/251002-1.png"/>

**프렌드로 초대하는 3가지 유형**<br>
◼ 전역 함수 : 클래스 외부에 선언된 전역 함수<br>
◼ 다른 클래스의 멤버 함수 : 다른 클래스의 특정 멤버 함수<br>
◼ 다른 클래스 전체 : 다른 클래스의 모든 멤버 함수

<img src="/assets/images/2025/10/02/251002-2.png"/>

**연산자 중복**

- 일상 생활에서의 기호 사용<br>
  - 기호의 사례<br>
    숫자 더하기 : 2 + 3 = 5<br>
    색 혼합 : 빨강 + 파랑 = 보라<br>
    생활 : 남자 + 여자 = 결혼<br>
  - 기호를 숫자와 물체에 적용, 중복 사용<br>
  - 기호를 숫자가 아닌 곳에도 사용<br>
  - 간결한 의미 전달<br>
  - 다형성<br>
- C++ 언어에서도 연산자 중복 가능<br>
  - C++ 언어에 본래부터 있든 연산자에 새로운 의미 정의<br>
  - 높은 프로그램 가독성

**연산자 중복의 특징**

- C++에 본래 있는 연산자만 중복 가능<br>
  3%%5 // 컴파일 오류<br>
  6##7 // 컴파일 오류<br>
- 피 연산자 타입이 다른 새로운 연산 정의<br>
- 연산자는 함수 형태로 구현 - 연산자 함수(operator function)<br>
- 반드시 클래스와 관계를 가짐<br>
- 피연산자의 개수를 바꿀 수 없음<br>
- 연산의 우선 순위 변경 안됨<br>
- 모든 연산자가 중복 가능하지 않음

<img src="/assets/images/2025/10/02/251002-3.png"/>

**연산자 함수**

- 연산자 함수 구현 방법 2 가지<br>
  1. 클래스의 멤버 함수로 구현<br>
  2. 외부 함수로 구현하고 클래스에 프렌드 함수로 선언<br>
- 연산자 함수 형식<br>
  리턴타입 operator연산자(매개변수리스트);

<img src="/assets/images/2025/10/02/251002-4.png"/>

**▼ 연산자 함수 구현 예제**

```c++
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	void show();
	Power operator+ (Power op2);
	Power operator+ (int op2);
	friend Power operator+ (int op1, Power op2);
	bool operator== (Power op2);
	Power& operator+= (Power op2);
	Power& operator++ ();
	Power operator++ (int x);
	Power& operator<< (int n);
};

void Power::show() {
	cout << "kick = " << kick << ',' << "punch = " << punch << endl;
}

Power Power::operator+(Power op2) {
	Power tmp;
	tmp.kick = this->kick + op2.kick;
	tmp.punch = this->punch + op2.punch;
	return tmp;
}

Power Power::operator+(int op2) {
	Power tmp;
	tmp.kick = kick + op2;
	tmp.punch = punch + op2;
	return tmp;
}

Power operator+(int op1, Power op2) {
	Power tmp;
	tmp.kick = op1 + op2.kick;
	tmp.punch = op1 + op2.punch;
	return tmp;
}

bool Power::operator==(Power op2) {
	if (kick == op2.kick && punch == op2.punch)return true;
	else return false;
}

Power& Power::operator+=(Power op2) {
	kick += op2.kick;
	punch += op2.punch;
	return *this;
}

Power& Power::operator++() {
	kick++;
	punch++;
	return *this;
}

Power Power::operator++(int x) {
	Power tmp = *this;
	kick++;
	punch++;
	return tmp;
}

Power& Power::operator<<(int n) {
	kick += n;
	punch += n;
	return *this;
}
```
