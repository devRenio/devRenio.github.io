---
layout: blog
title: 프로세스 관리
date: 2025-10-31 15:00:00 +0900
categories: [LECTURE, 서버프로그래밍]
permalink: /blog/posts/25-10-31-TIL
---

## 서버프로그래밍(황승연) 9주차 강의내용

### 프로세스

- **프로세스의 개념**

  - 저장장치(하드 디스크 등)에 저장된 프로그램이 메모리에 적재되어 CPU의 제어를 받아 실행 중인 상태<br>
    **실행 중인 프로그램 = 프로세스**
  - 프로그램이 실행되면 하나 이상의 프로세스가 생성되며 운영체제는 이 프로세스의 실행 상태, 자원, 스케줄링을 관리 (커널의 기능)<br><br>

- **프로세스 상태 전이**

  - 프로세스는 운영체제의 스케줄러에 의해 상태가 전이됨<br>
    생성(new) → 준비(ready) → 실행(running) → 대기(waiting) → 종료(terminated)
  - 하나의 프로그램이 실행되면 그 프로그램에 대응되는 프로세스가 생성되어 준비 큐(ready queue)에 들어감
  - CPU를 할당 받은 프로세스는 실행 상태가 되고 실행 도중 I/O 대기 등의 이유로 CPU를 반납하면 대기 상태로 전이됨
  - 다른 프로세스들이 CPU를 사용한 뒤 다시 스케줄링이 이루어지면 준비 상태에 있는 프로세스들이 차례대로 CPU를 할당 받음
  - 대부분의 현대 CPU는 멀티코어를 이용해 병렬로 프로세스를 처리하기에 여러 프로세스를 동시에 처리할 수 있음<br><br>

- **프로세스 상태 전이 (비유) - 조별 과제**

  - 팀장, 팀원 1, 팀원 2, 팀원 3, 팀원 4로 팀 구성<br>
    － 팀장 – 스케줄링<br>
    － 팀원 1, 2, 3 – 자료 제작<br>
    － 팀원 4 – 자료 취합 **(한 번에 한 명의 자료만 취합 가능)**
  - 팀원 1, 2, 3이 자료 제작 완료**(new)**하여 사용 가능 상태 **(ready)**
  - 팀장이 2 → 1 → 3 순으로 자료 취합 요청 **(스케줄링)**
  - 팀원 2의 자료를 취합 **(running → terminated)**
  - 팀원 4가 취합 중, 팀원 1의 자료가 미흡하여 거절 **(waiting)**
  - 팀원 1이 다시 작업 하는 동안 팀원 3 자료 취합 **(running → terminated)**
  - 팀원 3의 자료를 취합하는 동안 팀원 1의 자료 제작 완료 **(ready)**
  - 팀원 1의 자료 취합 **(running → terminated)**<br><br>

- **프로세스 번호와 작업 번호**

  - **프로세스 번호**<br>
    － CPU가 프로세스를 구분하기 위해 부여되는 고유 번호<br>
    － 각 프로세스가 가지는 고유의 번호를 PID라고 함
  - **작업 번호**<br>
    － 셀 환경에서 실행된 작업(포그라운드 또는 백그라운드)에 대해 사용자가 구분할 수 있도록 부여되는 일련번호
  - 프로세스 번호는 운영체제가 관리하는 번호이고 작업 번호는 사용자 세션 내에서 관리되는 번호<br><br>

- **프로세스 서비스와 관계**

  - **데몬 프로세스(Daemon Process)**
    － 사용자의 직접적인 입력 없이 시스템이 백그라운드에서 지속적으로 실행하는 프로세스
    － 네트워크, 인쇄, 로그 관리 등 특정 특정 서비스를 제공하기 위해 존재
    － 일반적으로 서비스 요청이 들어오면 즉시 응답하고, 요청이 없을 때는 대기 상태로 존재
    － ex) sshd, httpd, systemd 등<br><br>

- **부모-자식 프로세스**

  - 부모-자식 관계의 프로세스<br>
    － 자식 프로세스(새 프로세스)는 부모 프로세스(기존 프로세스)가 fork() 시스템 호출을 통해 생성<br>
    － 부모 프로세스는 PPID(Parent), 자식 프로세스는 PID를 가지고 있음<br>
    － 부모 프로세스를 종료하면 종속된 자식 프로세스도 함께 종료되거나 고아 프로세스가 될 수 있음<br><br>

- **고아 프로세스와 좀비 프로세스**
  - **고아 프로세스**<br>
    － 자식 프로세스가 종료되지 않은 상태에서 부모 프로세스가 종료되는 경우<br>
    － 고아 프로세스는 1번 프로세스(systemd)가 부모 역할을 이어받아 정상적으로 종료
  - **좀비 프로세스**<br>
    － 자식 프로세스가 실행을 완료했지만, 부모 프로세스가 종료 처리하지 않은 경우<br>
    － 좀비 프로세스는 **kill** 명령으로 제거할 수 없으며 부모 프로세스를 종료하면 자동으로 종료됨<br><br><br>

### 프로세스 관리 명령

**ps [옵션]** : 프로세스 상태 확인

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:15%">구분</th>
   <th style="width:20%">옵션</th>
   <th>설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td rowspan="4">유닉스</td>
   <td>-e</td>
   <td>시스템에서 실행 중인 모든 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td>-f</td>
   <td>프로세스에 대한 상세한 정보 출력</td>
  </tr>
  <tr>
   <td>-u UID</td>
   <td>특정 사용자에 대한 모든 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td>-p PID</td>
   <td>PID로 지정한 특정 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td rowspan="3">BSD</td>
   <td>a</td>
   <td>터미널에서 실행한 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td>u</td>
   <td>프로세스 소유자의 이름, CPU와 메모리 사용량 등 상세한 정보 출력</td>
  </tr>
  <tr>
   <td>x</td>
   <td>시스템에서 실행 중인 모든 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td>GNU</td>
   <td>--pid PID 목록</td>
   <td>목록으로 지정한 특정 PID 정보 출력</td>
  </tr>
 </tbody>
</table>

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:12%">항목</th>
   <th style="width:38%">기능</th>
   <th style="width:12%">항목</th>
   <th style="width:38%">기능</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>UID</td>
   <td>프로세스를 실행한 사용자 ID</td>
   <td>STIME</td>
   <td>프로세스 시작 날짜 또는 시각</td>
  </tr>
  <tr>
   <td>PID</td>
   <td>실행 프로세스 번호</td>
   <td>TTY</td>
   <td>터미널의 종류와 번호</td>
  </tr>
  <tr>
   <td>PPID</td>
   <td>부모 프로세스 번호</td>
   <td>TIME</td>
   <td>프로세스 실행 시간</td>
  </tr>
  <tr>
   <td>C</td>
   <td>CPU 사용량을 % 값으로 표시</td>
   <td>CMD</td>
   <td>실행되고 있는 프로그램 이름</td>
  </tr>
 </tbody>
</table>

입력 예 : **ps -ef**

**pgrep [옵션] [인자]** : 특정 프로세스 정보 검색

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:25%">옵션</th>
   <th style="width:75%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-x</td>
   <td>인자와 정확히 일치하는 패턴의 프로세스 정보 출력</td>
  </tr>
  <tr>
   <td>-n</td>
   <td>인자를 포함하고 있는 가장 최근의 프로세스 정보 출력</td>
  </tr>
  <tr>
   <td>-u 사용자 계정 이름</td>
   <td>특정 사용자 계정에 대한 모든 프로세스의 정보 출력</td>
  </tr>
  <tr>
   <td>-l</td>
   <td>PID와 프로세스의 이름 출력</td>
  </tr>
  <tr>
   <td>-t term</td>
   <td>특정 단말기와 관련된 프로세스의 정보 출력</td>
  </tr>
 </tbody>
</table>

입력 예 : **pgrep -x bash**

활용 예 : **ps -fp $(pgrep -x bash)**<br>
pgrep으로 반환한 bash의 PID로 ps 검색 실행

프로세스명으로 검색 : pgrep [프로세스명]<br>
프로세스ID(PID)로 검색 : ps -p [PID]

**kill [시그널] PID** : 프로세스 종료

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:20%">시그널(옵션)</th>
   <th style="width:80%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-2</td>
   <td>인터럽트 시그널 전송 (Ctrl+C)</td>
  </tr>
  <tr>
   <td>-9</td>
   <td>프로세스 강제 종료</td>
  </tr>
  <tr>
   <td>-15</td>
   <td>프로세스가 관련 파일을 정리 후 종료(종료되지 않는 프로세스도 존재)</td>
  </tr>
 </tbody>
</table>

**yes > /dev/null** : 테스트용 무한루프 명령 프로세스 실행<br>
두 번째 터미널을 열고 kill -9 [PID] 수행 시 yes 터미널에서 [죽었음] 출력되며 yes 프로세스 종료<br>
입력 예 : **kill -9 4556**

**pkill [시그널] [프로세스명]** : 프로세스 종료<br>
같은 이름의 명령 모두 종료<br><br><br>

### 포그라운드와 백그라운드

**포그라운드**

- 터미널 창에서 명령어를 입력하면 셸은 사용자가 입력한 명령을 수행하여 그 결과를 화면에 보여줌
- 사용자는 화면에 나타난 출력결과를 보고 다른 명령을 입력하는 대화식으로 수행하는 작업
- 즉 사용자와 상호작용을 하여 작업을 수행하도록 해주는 프로세스를 포그라운드 작업이라고 함<br><br>

**백그라운드**

- 프로세스가 실행되었지만 직접 눈으로 프로세스가 확인되지 않는 작업을 백그라운드 작업이라고 함
- 예를 들어 백신 프로그램, 서버 데몬 등과 같이 화면에 나타나 눈에 보이지는 않지만 실행되는 명령을 작업을 의미
- 이때 수행하는 프로세스를 백그라운드 프로세스라고 함<br><br>

**sleep [시간(초)]** : 설정 시간만큼 휴식<br>
쉬는 동안 터미널 사용 불가능, PID 반환

활용 예 : **sleep 30&**<br>
30초 동안 쉬는 프로세스를 백그라운드로 실행 이후 터미널을 사용자에게 반환<br>
하지만 진정한 백그라운드 프로세스는 아님<br>
터미널에 종속되어 터미널 종료 시 프로세스도 종료

**nohup** : 터미널을 종료해도 프로세스가 실행되도록 함<br>
입력 예 : **nohup sleep 300 > sleep.log 2>&1 &**<br>
**2>** : 에러 출력 스트림<br>
**&1** : 표준 출력 스트림<br>
sleep.log 파일에 표준 출력과 에러 출력을 모두 출력하라<br><br>

- **작업 제어**
  - 포그라운드 작업을 백그라운드 작업으로 전환하거나 백그라운드 작업을 포그라운드 작업으로 전환하는 제어를 의미
  - 작업 제어는 작업 전환과 작업의 일시 중지, 작업 종료로 구분되어 수행됨

**jobs [%작업 번호]** : 현재 실행 중인 작업 목록 출력

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:30%">옵션</th>
   <th>설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>%번호</td>
   <td>해당 작업의 정보만 출력</td>
  </tr>
  <tr>
   <td>%+ 또는 %%</td>
   <td>작업순서가 +인 작업 정보를 출력</td>
  </tr>
  <tr>
   <td>%-</td>
   <td>작업순서가 -인 작업 정보를 출력</td>
  </tr>
 </tbody>
</table>

- **작업 전환**<br>
  － 현재 포그라운드로 실행 중인 작업을 백그라운드 작업으로 전환하거나 백그라운드 작업을 포그라운드 작업으로 전환<br>
  － 작업 전환 명령은 다음 표와 같음

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:40%">명령</th>
   <th style="width:60%">의미</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Ctrl+Z 또는 stop [%작업 번호]</td>
   <td>포그라운드 작업을 잠시 중단</td>
  </tr>
  <tr>
   <td>Ctrl+C</td>
   <td>포그라운드 작업을 강제 종료</td>
  </tr>
  <tr>
   <td>kill [%작업 번호]</td>
   <td>백그라운드 작업을 강제 종료</td>
  </tr>
  <tr>
   <td>bg [%작업 번호]</td>
   <td>작업 번호가 지시하는 작업을 백그라운드로 전환</td>
  </tr>
  <tr>
   <td>fg [%작업 번호]</td>
   <td>작업 번호가 지시하는 작업을 포그라운드로 전환</td>
  </tr>
 </tbody>
</table>
