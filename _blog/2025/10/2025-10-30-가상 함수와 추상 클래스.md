---
layout: blog
title: 가상 함수와 추상 클래스
date: 2025-10-30 9:00:00 +0900
categories: [LECTURE, 객체지향프로그래밍II]
permalink: /blog/posts/25-10-30-TIL
---

## 객체지향프로그래밍II(김정준) 9주차 강의내용

### 가상 함수와 오버라이딩

- **가상 함수(virtual function)**
  - **virtual** 키워드로 선언된 멤버 함수
  - **virtual** 키워드의 의미<br>
    ◼ 동적 바인딩 지시어<br>
    ◼ 컴파일러에게 함수에 대한 호출 바인딩을 실행 시간까지 미루도록 지시

```c++
class Base {
public:
   virtual void f(); // 가상 함수
};
```

- **함수 오버라이딩(function overriding)**

  - 파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언<br>
    ◼ 기본 클래스의 가상 함수의 존재감 상실시킴<br>
    ◼ 파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩<br>
    ◼ **다형성**의 한 종류
  - 용어 정리<br>
    ◼ **오버라이딩** : 가상 함수를 재정의<br>
    ◼ **함수 재정의** : 일반 함수를 재정의
  - 가상 함수를 통해 파생 클래스에서 재정의할 함수에 대한 인터페이스를 제작 가능<br><br>

- **동적 바인딩**

  - 파생 클래스에 대해
  - 기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우
  - 객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행<br>
    ◼ 실행 중에 이루어짐<br>
    ◼ 실행시간 바인딩, 런타임 바인딩, 늦은 바인딩으로 불림<br><br>

- 오버라이딩의 성공 조건<br>
  ◼ 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 모두 일치
- 오버라이딩 시 virtual 지시어 생략 가능<br>
  ◼ 가상 함수의 virtual 지시어는 상속됨, 파생 클래스에서 virtual 생략 가능
- 가상 함수의 접근 지정<br>
  ◼ private, protected, public 중 자유롭게 지정 가능<br><br>

- **범위 지정 연산자(::)**

  - 정적 바인딩 지시
  - 기본클래스::가상함수() 형태로 기본 클래스의 가상 함수를 정적 바인딩으로 호출

- **가상 소멸자**<br>
  ◼ 소멸자를 virtual 키워드로 선언<br>
  ◼ 소멸자 호출 시 동적 바인딩 발생<br><br>

### 순수 가상 함수와 추상 클래스

- 기본 클래스의 가상 함수 목적
  - 파생 클래스에서 재정의할 함수를 알려주는 역할<br>
    ◼ 실행할 코드를 작성할 목적이 아님
  - 기본 클래스의 가상 함수를 굳이 구현할 필요가 있을까?
- **순수 가상 함수(pure virtual function)**
  - 함수의 코드가 없고 선언만 있는 가상 멤버 함수
  - 선언 방법<br>
    ◼ 멤버 함수의 원형=0;으로 선언

```c++
class Shape {
public:
   virtual void draw()=0; // 순수 가상 함수 선언
};
```

- **추상 클래스** : 최소한 하나의 순수 가상 함수를 가진 클래스
- 추상 클래스의 특징

  - 온전한 클래스가 아니므로 객체 생성 불가능
  - 추상 클래스의 포인터는 선언 가능

- 추상 클래스의 목적

  - 추상 클래스의 인스턴스를 생성할 목적 아님
  - 상속에서 기본 클래스의 역할을 하기 위함<br>
    ◼ 순수 가상 함수를 통해 파생 클래스에서 구현할 함수의 형태(원형)을 보여주는 인터페이스 역할<br>
    ◼ 추상 클래스의 모든 멤버 함수를 순수 가상 함수로 선언할 필요 없음

- 추상 클래스의 상속
  - 추상 클래스를 단순 상속하면 자동 추상 클래스
- 추상 클래스의 구현
  - 추상 클래스를 상속받아 순수 가상 함수를 오버라이딩<br>
    ◼ 파생 클래스는 추상 클래스가 아님

