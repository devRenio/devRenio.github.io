---
layout: blog
title: 템플릿과 표준 템플릿 라이브러리(STL)
date: 2025-11-06 9:00:00 +0900
categories: [LECTURE, 객체지향프로그래밍II]
permalink: /blog/posts/25-11-06-TIL
---

## 객체지향프로그래밍II(김정준) 10주차 강의내용

### 일반화와 템플릿

- **제네릭(generic) or 일반화**
  - 함수나 클래스를 일반화시키고, 매개 변수 타입을 지정하여 틀에서 찍어 내듯이
  - 함수나 클래스 코드를 생산하는 기법
- **템플릿**
  - 함수나 클래스를 일반화하는 C++ 도구
  - template 키워드로 함수나 클래스 선언<br>
    ◼ 변수나 매개 변수의 타입만 다르고, 코드 부분이 동일한 함수를 일반화시킴
  - 제네릭 타입 - 일반화를 위한 데이터 타입
  - 템플릿 함수보다 중복 함수가 우선 호출
- **구체화(specialization)**
  - 템플릿의 제네릭 타입에 구체적인 타입 지정<br>
    ◼ 템플릿 함수로부터 구체화된 함수의 소스 코드 생성
  - 같은 제네릭 타입에는 같은 타입의 매개변수만을 사용해야 함

```c++
template <class T> // 템플릿 선언
template <class T1, class T2> // T1과 T2는 다를 수 있음
template <typename T>
```

```c++
void myswap (T & a, T & b) { // 구체화
  T tmp;
  tmp = a;
  a = b;
  b = tmp;
}
```

- **템플릿의 장점**
  - 함수 코드의 재사용<br>
    ◼ 높은 소프트웨어의 생산성과 유용성
- **템플릿의 단점**
  - 포팅에 취약<br>
    ◼ 컴파일러에 따라 지원하지 않을 수 있음
  - 컴파일 오류 메시지 빈약, 디버깅에 많은 어려움
- **제네릭 프로그래밍**
  - generic programming<br>
    ◼ 일반화 프로그래밍이라고도 부름<br>
    ◼ 제네릭 함수나 제네릭 클래스를 활용하는 프로그래밍 기법<br>
    ◼ C++에서 STL(Standard Template Library) 제공. 활용
  - 보편화 추세<br>
    ◼ Java, C# 등 많은 언어에서 활용

```c++
template <class T>
T add(T data [], int n) { // 제네릭타입 배열 data
  ...
}
```

<br><br>

### 제네릭 클래스

```c++
template <class T>
class MyStack { ... }; // 제네릭 클래스 선언

template <class T>
void MyStack<T>::push(T element) { ... } // 제네릭 클래스 구현

MyStack<int> iStack; // 제네릭 클래스 구체화(객체 생성)
```

<br><br>

### C++ 표준 템플릿 라이브러리, STL

- **STL(Standard Template Library)**
  - **표준 템플릿 라이브러리**<br>
    ◼ C++ 표준 라이브러리 중 하나
  - 많은 제네릭 클래스와 제네릭 함수 포함<br>
    ◼ 개발자는 이들을 이용하여 쉽게 응용 프로그램 작성
- **STL의 구성**

  - **컨테이너** – 템플릿 클래스<br>
    ◼ 데이터를 담아두는 자료 구조를 표현한 클래스<br>
    ◼ 리스트, 큐, 스택, 맵, 셋, 벡터
  - **iterator** – 컨테이너 원소에 대한 포인터<br>
    ◼ 컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터
  - **알고리즘** – 템플릿 함수<br>
    ◼ 컨테이너 원소에 대한 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿 함수<br>
    ◼ 컨테이너의 멤버 함수 아님

<table style="width:85%" border="1">
<caption>STL 컨테이너의 종류</caption>
 <thead>
  <tr>
   <th style="width:17%">컨테이너 클래스</th>
   <th style="width:55%">설명</th>
   <th>헤더 파일</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>vector</td>
   <td>가변 크기의 배열을 일반화한 클래스</td>
   <td>&lt;vector&gt;</td>
  </tr>
  <tr>
   <td>deque</td>
   <td>앞뒤 모두 입력 가능한 큐 클래스</td>
   <td>&lt;deque&gt;</td>
  </tr>
  <tr>
   <td>list</td>
   <td>빠른 삽입/삭제 가능한 리스트 클래스</td>
   <td>&lt;list&gt;</td>
  </tr>
  <tr>
   <td>set</td>
   <td>정렬된 순서로 값을 저장하는 집합 클래스. 값은 유일</td>
   <td>&lt;set&gt;</td>
  </tr>
  <tr>
   <td>map</td>
   <td>(key, value) 쌍을 저장하는 맵 클래스</td>
   <td>&lt;map&gt;</td>
  </tr>
  <tr>
   <td>stack</td>
   <td>스택을 일반화한 클래스</td>
   <td>&lt;stack&gt;</td>
  </tr>
  <tr>
   <td>queue</td>
   <td>큐를 일반화한 클래스</td>
   <td>&lt;queue&gt;</td>
  </tr>
 </tbody>
</table>

<table style="width:85%" border="1">
<caption>STL iterator의 종류</caption>
 <thead>
  <tr>
   <th>iterator의 종류</th>
   <th>iterator에 ++ 연산 후 방향</th>
   <th style="width:15%">read/write</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>iterator</td>
   <td>다음 원소로 전진</td>
   <td>read/write</td>
  </tr>
  <tr>
   <td>const_iterator</td>
   <td>다음 원소로 전진</td>
   <td>read</td>
  </tr>
  <tr>
   <td>reverse_iterator</td>
   <td>지난 원소로 후진</td>
   <td>read/write</td>
  </tr>
  <tr>
   <td>const_reverse_iterator</td>
   <td>지난 원소로 후진</td>
   <td>read</td>
  </tr>
 </tbody>
</table>

<table style="width:85%" border="1">
<caption>STL 알고리즘 함수들</caption>
 <tbody>
  <tr>
   <td>copy</td>
   <td>merge</td>
   <td>random</td>
   <td>rotate</td>
  </tr>
  <tr>
   <td>equal</td>
   <td>min</td>
   <td>remove</td>
   <td>search</td>
  </tr>
  <tr>
   <td>find</td>
   <td>move</td>
   <td>replace</td>
   <td>sort</td>
  </tr>
  <tr>
   <td>max</td>
   <td>partition</td>
   <td>reverse</td>
   <td>swap</td>
  </tr>
 </tbody>
</table>

- **헤더파일**
  - 컨테이너 클래스를 사용하기 위한 헤더 파일<br>
    ◼ 해당 클래스가 선언된 헤더 파일 include<br>
    예) vector 클래스를 사용하려면 #include \<vector><br>
    list 클래스를 사용하려면 #include \<list>
  - 알고리즘 함수를 사용하기 위한 헤더 파일<br>
    ◼ 알고리즘 함수에 상관 없이 #include \<algorithm>
- **이름 공간**
  - STL이 선언된 이름 공간은 std<br><br>

### vector 컨테이너

- **특징**
  - 가변 길이 배열을 구현한 제네릭 클래스<br>
    ◼ 개발자가 벡터의 길이에 대한 고민할 필요 없음
  - 원소의 저장, 삭제, 검색 등 다양한 멤버 함수 지원
  - 벡터에 저장된 원소는 인덱스로 접근 가능<br>
    ◼ 인덱스는 0부터 시작

<table style="width:85%" border="1">
 <caption>vector의 주요 멤버와 연산자</caption>
 <thead>
  <tr>
   <th style="width:30%">멤버와 연산자 함수</th>
   <th>설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>push_back(element)</td>
   <td>벡터의 마지막에 element 추가</td>
  </tr>
  <tr>
   <td>at(int index)</td>
   <td>index 위치의 원소에 대한 참조 리턴</td>
  </tr>
  <tr>
   <td>begin()</td>
   <td>벡터의 첫 번째 원소에 대한 참조 리턴</td>
  </tr>
  <tr>
   <td>end()</td>
   <td>벡터의 끝(마지막 원소 다음)을 가리키는 참조 리턴</td>
  </tr>
  <tr>
   <td>empty()</td>
   <td>벡터가 비어 있으면 true 리턴</td>
  </tr>
  <tr>
   <td>erase(iterator it)</td>
   <td>벡터에서 it가 가리키는 원소 삭제. 삭제 후 자동으로 벡터 조절</td>
  </tr>
  <tr>
   <td>insert(iterator it, element)</td>
   <td>벡터 내 it 위치에 element 삽입</td>
  </tr>
  <tr>
   <td>size()</td>
   <td>벡터에 들어 있는 원소의 개수 리턴</td>
  </tr>
  <tr>
   <td>operator[]()</td>
   <td>지정된 원소에 대한 참조 리턴</td>
  </tr>
  <tr>
   <td>operator=()</td>
   <td>이 벡터를 다른 벡터에 치환(복사)</td>
  </tr>
 </tbody>
</table>

- **iterator 사용**
  - iterator란?<br>
    ◼ 반복자라고도 부름
  - 컨테이너의 원소를 가리키는 포인터<br>
    ◼ iterator 변수 선언
  - 구체적인 컨테이너를 지정하여 반복자 변수 생성

```c++
vector<int>::iterator it;
it = v.begin();
```
