---
layout: blog
title: 소프트웨어 관리
date: 2025-11-07 15:00:00 +0900
categories: [LECTURE, 서버프로그래밍]
permalink: /blog/posts/25-11-07-TIL
---

## 서버프로그래밍(황승연) 10주차 강의내용

### 패키지 설치

- 우분투에서 패키지를 설치하는 3가지 방법
  - **APT(Advanced Package Tool)** 명령 사용
  - **dpkg(Debian package)** 명령 사용
  - **aptiude** 명령 사용
- **APT 명령**
  - APT의 대표적인 명령 : **apt-cache** 명령과 **apt-get** 명령
  - Ubuntu 18.04 LTS 버전부터 apt-cache 명령과 apt-get 명령을 일부 통합한 apt 명령을 제공하고 있지만
  - apt-cache명령과 apt-get 명령을 모두 대체할 수 있는 상황은 아니므로 여기서는 apt-cache 명령과 apt-get 명령을 모두 사용

**apt-cache [옵션] [서브 명령]** : APT 캐시에서 패키지와 관련된 정보를 출력<br>
패키지 이름, 버전, 설명, 의존성, 설치 가능 여부 확인 가능<br>
패키지를 설치하지 않고도 미리 확인할 수 있음

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:30%">옵션/서브 명령</th>
   <th style="width:70%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-f</td>
   <td>패키지에 대한 전체 정보 출력</td>
  </tr>
  <tr>
   <td>-h</td>
   <td>관련 도움말 출력</td>
  </tr>
  <tr>
   <td>stats</td>
   <td>캐시 통계 정보(전체 패키지 이름과 단일 가상 패키지 등) 출력</td>
  </tr>
  <tr>
   <td>dump</td>
   <td>패키지 관리 시스템이 현재 알고 있는 모든 패키지 정보를 출력</td>
  </tr>
  <tr>
   <td>pkgnames</td>
   <td>사용 가능한 모든 패키지의 이름 출력</td>
  </tr>
  <tr>
   <td>search [키워드]</td>
   <td>키워드에 해당하는 패키지 검색</td>
  </tr>
  <tr>
   <td>show [패키지 이름]</td>
   <td>해당 패키지의 정보 출력</td>
  </tr>
  <tr>
   <td>showpkg [패키지 이름]</td>
   <td>패키지의 의존성과 역의존성에 대한 정보 출력</td>
  </tr>
 </tbody>
</table><br>

입력 예 : **apt-cache stats**

- 패키지 관리 시스템이 보유하고 있는 로컬 패키지 캐시의 통계 정보
- 출력 내용에는 전체 패키지 개수, 설치 가능한 일반 패키지 수, 순수 가상 패키지(pure virtual), 단일 가상 패키지(single virtual), 혼합 가상 패키지(mixed virtual) 등의 항목이 포함
- (순수 가상 패키지) 이름만 있고 실제 파일은 없음 → 이 이름으로 설치되는 다른 패키지가 존재
- (단일 가상 패키지) 가상 이름이지만, 그 이름과 연결된 실제 패키지가 하나인 경우
- (혼합 가상 패키지) 혼합 가상 패키지는 실제 패키지가 존재하면서 동시에 다른 패키지들도 그 이름(가상 이름)을 제공하는 패키지
  <br><br>

**apt-get [옵션] [서브 명령]** : 패키지 설치 및 업데이트 명령

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:30%">옵션/서브 명령</th>
   <th style="width:70%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-d</td>
   <td>패키지 다운로드 수행</td>
  </tr>
  <tr>
   <td>-f</td>
   <td>의존성이 깨진 패키지 수정</td>
  </tr>
  <tr>
   <td>-h</td>
   <td>관련 도움말 출력</td>
  </tr>
  <tr>
   <td>update</td>
   <td>패키지 저장소에서 새로운 패키지 정보를 가져옴</td>
  </tr>
  <tr>
   <td>upgrade</td>
   <td>모든 패키지를 최신 버전으로 업그레이드</td>
  </tr>
  <tr>
   <td>install [패키지 이름]</td>
   <td>해당 패키지 설치</td>
  </tr>
  <tr>
   <td>-y</td>
   <td>패키지를 설치할 때 자동으로 y 입력</td>
  </tr>
  <tr>
   <td>remove [패키지 이름]</td>
   <td>설치된 해당 패키지 제거(설정 파일 잔존)</td>
  </tr>
  <tr>
   <td>purge [패키지 이름]</td>
   <td>설치된 해당 패키지와 설정 파일을 모두 삭제</td>
  </tr>
  <tr>
   <td>autoremove</td>
   <td>시스템에 설치된 패키지를 자동으로 정리 및 삭제</td>
  </tr>
  <tr>
   <td>download [패키지 이름] [패키지 이름] ...</td>
   <td>해당 패키지를 현재 디렉터리에 다운로드</td>
  </tr>
  <tr>
   <td>autoclean</td>
   <td>오래된 패키지 또는 불완전한 다운로드 패키지 제거</td>
  </tr>
  <tr>
   <td>check</td>
   <td>의존성이 깨진 패키지 확인</td>
  </tr>
  <tr>
   <td>clean</td>
   <td>/var/cache/apt/archives 디렉터리에 캐시되어 있는 모든 패키지를 제거하여 디스크 공간 확보</td>
  </tr>
 </tbody>
</table>

입력 예 : **sudo apt-get update**<br>
update 명령을 수행하면 /etc/apt/sources.list.d/ubuntu.sources에서 새로운 패키지 정보를 가져와서 APT 캐시를 수정<br>
만약 이 파일을 수정하였다면 반드시 이 명령을 수행해야 함<br><br>

**dpkg [옵션] [패키지/파일 이름]** : .deb 패키지를 직접 설치, 제거, 조회

- APT 명령은 소프트웨어 관리를 위해 내부적으로 DPKG 명령을 이용
- DPKG는 저장소(repository)가 없기 때문에 의존성 자동 해결, 원격 다운로드 기능은 제공하지 않음
- DPKG 명령과 APT 명령의 차이점<br>
  － DPKG 명령은 시스템의 특정 파일이 어느 패키지에 포함되어 있는지 등에 대한 구체적인 기능을 확인할 때 옵션과 함께 사용

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:35%">옵션/명령</th>
   <th style="width:65%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-l</td>
   <td>설치된 패키지 목록 전체 출력</td>
  </tr>
  <tr>
   <td>-l [패키지 이름]</td>
   <td>해당 패키지의 설치상태 정보 출력</td>
  </tr>
  <tr>
   <td>-r [패키지 이름]</td>
   <td>sudo 명령을 사용하여 해당 패키지를 삭제</td>
  </tr>
  <tr>
   <td>-P [패키지 이름]</td>
   <td>sudo 명령을 사용하여 해당 패키지와 설정 정보 모두 삭제</td>
  </tr>
  <tr>
   <td>-s [패키지 이름]</td>
   <td>해당 패키지의 자세한 정보 출력</td>
  </tr>
  <tr>
   <td>-L [패키지 이름]</td>
   <td>해당 패키지가 설치된 파일목록 출력</td>
  </tr>
  <tr>
   <td>-S [경로명]</td>
   <td>경로명이 포함된 패키지 검색</td>
  </tr>
  <tr>
   <td>-c [.파일 확장자]</td>
   <td>해당 파일 확장자를 가진 파일의 내용 출력</td>
  </tr>
  <tr>
   <td>-i [.파일 확장자]</td>
   <td>sudo 명령으로 해당 파일 확장자를 가진 파일 설치</td>
  </tr>
  <tr>
   <td>-x [.파일 확장자] [디렉터리명]</td>
   <td>해당 파일 확장자를 가진 파일을 지정한 디렉터리에 풀어놓음</td>
  </tr>
 </tbody>
</table>
<br><br>

### 파일 아카이브와 압축

**파일 아카이브**

- 아카이브(Archive)란 특정 시간에 함께 묶인 파일이나 디렉터리의 집합을 의미(저장소 또는 보관소)
- 아카이브는 다른 시스템과 파일이나 디렉터리를 주고 받거나 파일을 백업하는 용도로 사용
- 파일 아카이브를 위해 사용되는 명령은 tar, cpio, ar 등이 있음

**tar [기능[옵션]] [아카이브 생성 파일명] [대상 파일명]**

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:8%">구분</th>
   <th style="width:30%">옵션</th>
   <th style="width:62%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td rowspan="5">기능</td>
   <td>c</td>
   <td>새로운 tar 아카이브 생성</td>
  </tr>
  <tr>
   <td>r</td>
   <td>새로운 파일 추가</td>
  </tr>
  <tr>
   <td>t</td>
   <td>tar 파일에 존재하는 파일 리스트 출력</td>
  </tr>
  <tr>
   <td>u</td>
   <td>수정된 파일에 대해 업데이트 수행</td>
  </tr>
  <tr>
   <td>x</td>
   <td>tar 파일에 있는 원본 파일을 추출</td>
  </tr>
  <tr>
   <td rowspan="8">옵션</td>
   <td>C [디렉터리명]</td>
   <td>파일들을 특정 디렉터리에 풀어 놓음</td>
  </tr>
  <tr>
   <td>f [디바이스명 또는 파일명]</td>
   <td>아카이브 파일 또는 테이프 장치를 지정 (디바이스명을 -으로 지정하면 tar 파일 대신 표준입력에서 읽어 들임)</td>
  </tr>
  <tr>
   <td>h</td>
   <td>심볼릭 링크의 원본 파일 포함</td>
  </tr>
  <tr>
   <td>j</td>
   <td>bzip2로 압축 또는 해제</td>
  </tr>
  <tr>
   <td>p</td>
   <td>파일 복구 시 원래의 접근 권한을 유지</td>
  </tr>
  <tr>
   <td>v</td>
   <td>처리하고 있는 파일의 정보 출력</td>
  </tr>
  <tr>
   <td>z</td>
   <td>gzip으로 압축 또는 해제</td>
  </tr>
  <tr>
   <td>Z</td>
   <td>compress를 통해 아카이브를 필터링</td>
  </tr>
 </tbody>
</table>

입력 예 : **tar cvf arch_test.tar arch_test**<br>
arch_test 디렉터리를 대상으로 아카이브 파일 arch_test.tar을 생성

입력 예 : **tar tvf arch_test.tar**<br>
arch_test.tar 파일에 대한 상세한 정보를 출력(ls -l과 유사)

입력 예 : **tar xvf arch_test.tar**<br>
아카이브 파일 arch_test.tar을 해제

입력 예 : **tar uvf arch_test.tar arch_test**<br>
arch_test.tar의 내용을 arch_test의 내용으로 업데이트

입력 예 : **tar rvf arch_test.tar hosts**<br>
arch_test.tar 내에 hosts 파일을 추가

입력 예 : **tar cvzf arch_test.tar.gz arch_test**<br>
아카이브를 생성하는 동시에 arch_test.tar.gz(gzip 형식으로 압축) 압축 파일로 생성

입력 예 : **tar cvjf arch_test.tar.bz2 arch_test**<br>
아카이브를 생성하는 동시에 arch_test.tar.bz2(bzip2 형식으로 압축) 압축 파일로 생성

**tar xvzf/xvjf** : 압축 해제
<br><br>

**파일 압축과 해제**

**gzip [옵션] [파일명]** : 파일을 gzip 형식으로 압축

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:20%">옵션</th>
   <th style="width:80%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-d</td>
   <td>파일 압축 해제</td>
  </tr>
  <tr>
   <td>-l</td>
   <td>압축된 파일의 정보 출력</td>
  </tr>
  <tr>
   <td>-r</td>
   <td>하위 디렉터리로 이동하여 파일 압축</td>
  </tr>
  <tr>
   <td>-t</td>
   <td>압축 파일 검사</td>
  </tr>
  <tr>
   <td>-v</td>
   <td>압축 정보를 화면에 출력</td>
  </tr>
  <tr>
   <td>-9</td>
   <td>최대한 압축</td>
  </tr>
 </tbody>
</table>

입력 예 : **gzip arch_test.tar arch_test**<br>
arch_test.tar 파일을 arch_test.tar.gz 파일로 압축<br>
arch_test의 경우 디렉터리이기 때문에 압축이 불가능

**zcat [파일명]** : 압축 파일 내용 확인<br>
입력 예 : zcat arch_test.tar.gz

**gunzip [파일명]** : 압축 파일 해제(g+un+zip)<br>
입력 예 : gunzip arch_test.tar.gz<br><br>

**bzip2** : 파일을 bzip2 형식으로 압축<br>
bzip2는 gzip에 비해 압축률은 좋지만 속도가 약간 느림

<table style="width:85%" border="1">
 <thead>
  <tr>
   <th style="width:20%">옵션</th>
   <th style="width:80%">설명</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>-d</td>
   <td>파일 압축 해제</td>
  </tr>
  <tr>
   <td>-l</td>
   <td>압축된 파일의 정보 출력</td>
  </tr>
  <tr>
   <td>-t</td>
   <td>압축 파일 검사</td>
  </tr>
  <tr>
   <td>-v</td>
   <td>압축 정보를 화면에 출력</td>
  </tr>
  <tr>
   <td>-best</td>
   <td>최대한 압축</td>
  </tr>
 </tbody>
</table>

입력 예 : **bzip2 arch_test.tar arch_test**<br>
arch_test.tar 파일을 arch_test.tar.bz2 파일로 압축<br>
arch_test의 경우 디렉터리이기 때문에 압축이 불가능

**bzcat [파일명]** : 압축 파일 내용 확인<br>
입력 예 : bzcat arch_test.tar.bz2

**bunzip2 [파일명]** : 압축 파일 해제(b+un+zip2)<br>
입력 예 : bunzip2 arch_test.tar.bz2<br><br>

### 소프트웨어 컴파일

- **컴파일러의 개념**
  - **컴파일러(Compiler)**란 자연어로 구성된 고급언어(C 언어, Java 등)를 컴퓨터가 이해할 수 있는 기계어(0과 1)로 **번역해 주는 소프트웨어**를 의미
  - 자연어를 기계어로 번역해 주는 과정을 **컴파일(Compile)**라고 함
  - C 언어로 작성한 프로그램을 컴퓨터가 실행할 수 있도록 컴파일을 수행하려면 C 컴파일러가 필요
- **gcc 컴파일러**
  - 우분투에서 사용하는 C 컴파일러는 **gcc**

**gcc [옵션] [파일명]** : c 소스 파일에 대한 컴파일을 수행<br>
디폴트 실행 파일명 : a.out

입력 예 : **gcc ex_01.c**<br>
ex_01.c 파일을 컴파일하여 실행 파일 a.out으로 생성<br>
a.out 실행 시 ./a.out과 같이 주소 지정 필요(경로가 설정되지 않았기 때문)

**gcc -o [변경할 실행파일명] [C 프로그램 소스 파일명]** : 실행파일명 지정<br><br>

### geany IDE

geany IDE를 사용하여 C 프로그래밍 환경 구성
